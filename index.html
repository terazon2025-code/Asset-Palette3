<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Asset Palette</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet" crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.min.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'Noto Sans JP', 'sans-serif'],
            },
          },
        },
      }
    </script>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.3.1",
    "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
    "recharts": "https://esm.sh/recharts@2.12.7",
    "react-dom/": "https://esm.sh/react-dom@18.3.1/",
    "react/": "https://esm.sh/react@18.3.1/"
  }
}
</script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-gray-50 text-gray-800">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
// --- ライブラリのインポート ---
import React, { useState, useCallback, useRef, useEffect, useMemo } from 'react';
import ReactDOM from 'react-dom/client';
import { PieChart, Pie, Cell, Tooltip, ResponsiveContainer } from 'recharts';

// --- 定数 (constants.ts) ---
const ASSET_TYPE_COLORS = {
  '国内株式': '#3b82f6', '米国株式': '#f97316', '中国株式': '#ec4899', 'アセアン株式': '#ef4444',
  '投資信託': '#22c55e', '金・プラチナ': '#eab308', '国内債券': '#6366f1', '外国債券': '#8b5cf6',
  '現金': '#6b7280', '仮想通貨': '#14b8a6',
};
const GENERAL_PALETTE = [
  '#6b21a8', '#1d4ed8', '#059669', '#d97706', '#db2777', '#64748b', '#4f46e5', '#c026d3',
];
const getTypeColor = (type) => ASSET_TYPE_COLORS[type] || '';
const getGeneralColor = (name) => {
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  return GENERAL_PALETTE[Math.abs(hash % GENERAL_PALETTE.length)];
};
const assetTypeOrder = {
  '国内株式': 1, '米国株式': 2, '中国株式': 3, 'アセアン株式': 4,
  '投資信託': 5, '金・プラチナ': 6, '国内債券': 7, '外国債券': 8,
  '現金': 98, '仮想通貨': 99,
};

// --- アイコン (components/icons.tsx) ---
const UploadIcon = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M3 17.25V21h18v-3.75m-18 0V12a2.25 2.25 0 012.25-2.25h13.5A2.25 2.25 0 0121 12v5.25" />
  </svg>
);
const ArrowLeftIcon = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
  </svg>
);
const DownloadIcon = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
  </svg>
);
const ChevronRightIcon = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
  </svg>
);
const PlusIcon = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
    </svg>
);
const PencilIcon = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" />
    </svg>
);
const TrashIcon = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
    </svg>
);
const EyeIcon = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M2.036 12.322a1.012 1.012 0 010-.639l4.443-7.24a1.011 1.011 0 011.21-.472c.31.11.53.385.53.712v1.5a.75.75 0 00.75.75H12a.75.75 0 00.75-.75v-1.5c0-.327.22-.602.53-.712a1.011 1.011 0 011.21.472l4.443 7.24c.03.05.054.102.072.155a1.012 1.012 0 010 .639l-4.443 7.24a1.011 1.011 0 01-1.21.472c-.31-.11-.53-.385-.53-.712v-1.5a.75.75 0 00-.75-.75H12a.75.75 0 00-.75.75v1.5c0 .327-.22.602-.53.712a1.011 1.011 0 01-1.21-.472L2.036 12.322z" />
    <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
  </svg>
);
const EyeSlashIcon = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M3.98 8.223A10.477 10.477 0 001.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.45 10.45 0 0112 4.5c4.756 0 8.773 3.162 10.065 7.498a10.523 10.523 0 01-4.293 5.774M6.228 6.228L3 3m3.228 3.228l3.65 3.65m7.894 7.894L21 21m-3.228-3.228l-3.65-3.65m0 0a3 3 0 10-4.243-4.243m4.243 4.243L6.228 6.228" />
  </svg>
);

// --- ヘルパー関数 ---
const useIsMobile = () => {
    const [isMobile, setIsMobile] = useState(window.innerWidth < 768);
    useEffect(() => {
        const handleResize = () => setIsMobile(window.innerWidth < 768);
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);
    return isMobile;
};

// --- コンポーネント (components/*.tsx) ---

const FileUpload = ({ onFileUpload }) => {
  const [isDragActive, setIsDragActive] = useState(false);
  const inputRef = useRef(null);

  const handleDrag = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setIsDragActive(true);
    } else if (e.type === 'dragleave') {
      setIsDragActive(false);
    }
  };

  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragActive(false);
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      onFileUpload(e.dataTransfer.files);
    }
  };

  const handleChange = (e) => {
    e.preventDefault();
    if (e.target.files && e.target.files[0]) {
      onFileUpload(e.target.files);
    }
  };

  const onButtonClick = () => {
    inputRef.current.click();
  };
  
  return (
    <div className="flex flex-col items-center justify-center min-h-screen p-4 sm:p-6">
      <div className="w-full max-w-2xl text-center">
        <h1 className="text-3xl sm:text-5xl font-bold mb-2">Asset Palette</h1>
        <p className="text-gray-600 mb-8 text-sm sm:text-base">あなたの資産ポートフォリオを、美しく、分かりやすく。</p>
        <form id="form-file-upload" onDragEnter={handleDrag} onSubmit={(e) => e.preventDefault()} className="w-full">
          <input ref={inputRef} type="file" id="input-file-upload" multiple={true} onChange={handleChange} className="hidden" accept=".csv" />
          <label
            htmlFor="input-file-upload"
            className={`w-full h-64 flex flex-col items-center justify-center border-2 border-dashed rounded-xl cursor-pointer transition-colors ${isDragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300 bg-white hover:bg-gray-50'}`}
          >
            {isDragActive && (
              <div onDragEnter={handleDrag} onDragLeave={handleDrag} onDragOver={handleDrag} onDrop={handleDrop} className="absolute inset-0" />
            )}
            <UploadIcon className="w-12 h-12 text-gray-400 mb-4" />
            <span className="font-semibold">ここにCSVファイルをドラッグ＆ドロップ</span>
            <span className="text-gray-500 mt-2">または</span>
            <button onClick={onButtonClick} className="mt-4 px-6 py-2 bg-blue-500 text-white rounded-md font-semibold hover:bg-blue-600 transition-colors">
              ファイルを選択
            </button>
          </label>
        </form>
         <div className="mt-8 text-left text-gray-600 text-xs sm:text-sm bg-gray-100 p-4 rounded-lg">
            <h3 className="font-bold mb-2">使い方</h3>
            <ul className="list-disc list-inside space-y-1">
                <li>楽天証券からダウンロードした「資産残高（CSV）」ファイルをインポートします。</li>
                <li>複数のファイルを一度に選択、またはドラッグ＆ドロップできます。</li>
                <li>CSVにない資産（現金など）はダッシュボードで手動追加できます。</li>
                <li>データはすべてブラウザ内で処理され、外部には送信されません。</li>
            </ul>
        </div>
      </div>
    </div>
  );
};

const Header = ({ portfolioName, portfolios, setActivePortfolioIndex, onDownload, isMasked, setIsMasked }) => {
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const dropdownRef = useRef(null);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsDropdownOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  return (
    <header className="flex items-center justify-between p-4 sm:p-6 bg-white/50 backdrop-blur-sm sticky top-0 z-10 border-b">
      <button onClick={() => setActivePortfolioIndex(null)} className="flex items-center text-sm font-semibold text-gray-600 hover:text-gray-900">
        <ArrowLeftIcon className="w-5 h-5 mr-2" />
        戻る
      </button>
      <div className="relative" ref={dropdownRef}>
        <button onClick={() => setIsDropdownOpen(!isDropdownOpen)} className="text-base sm:text-lg font-bold flex items-center">
          {portfolioName}
          <ChevronRightIcon className={`w-5 h-5 ml-1 transition-transform transform ${isDropdownOpen ? 'rotate-90' : ''}`} />
        </button>
        {isDropdownOpen && (
          <div className="absolute mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-20 right-0">
            {portfolios.map((p, index) => (
              <a
                key={index}
                href="#"
                onClick={(e) => {
                  e.preventDefault();
                  setActivePortfolioIndex(index);
                  setIsDropdownOpen(false);
                }}
                className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
              >
                {p.name}
              </a>
            ))}
          </div>
        )}
      </div>
      <div className="flex items-center space-x-1 sm:space-x-2">
        <button onClick={() => setIsMasked(!isMasked)} className="p-2 rounded-full hover:bg-gray-200 transition-colors" aria-label={isMasked ? "金額を表示" : "金額を非表示"}>
            {isMasked ? <EyeSlashIcon className="h-5 w-5 sm:h-6 sm:w-6" /> : <EyeIcon className="h-5 w-5 sm:h-6 sm:w-6" />}
        </button>
        <button onClick={onDownload} className="p-2 rounded-full hover:bg-gray-200 transition-colors" aria-label="画像をダウンロード">
          <DownloadIcon className="h-5 w-5 sm:h-6 sm:w-6" />
        </button>
      </div>
    </header>
  );
};

const SummaryCard = ({ summary, isMasked }) => {
  const { totalValue, totalGain, gainPercentage } = summary;
  const gainColor = totalGain >= 0 ? 'text-red-500' : 'text-blue-500';
  const gainSign = totalGain >= 0 ? '+' : '';

  return (
    <div className="bg-white p-4 sm:p-6 rounded-xl shadow-sm">
      <div className="text-3xl sm:text-5xl font-bold tracking-tight mb-1">
        {isMasked ? '********' : Math.round(totalValue).toLocaleString()}
        <span className="text-xl sm:text-3xl font-medium ml-2">円</span>
      </div>
      <div className="text-sm sm:text-base text-gray-500 mb-2">評価損益(率)</div>
      <div className={`text-lg sm:text-2xl font-semibold ${gainColor}`}>
        {gainSign}
        {isMasked ? '********' : Math.round(totalGain).toLocaleString()}円
        <span className="ml-2">({gainPercentage.toFixed(2)}%)</span>
      </div>
    </div>
  );
};

const PortfolioPieChart = ({ data, isMasked }) => {
  const [groupBy, setGroupBy] = useState('資産クラス');
  const isMobile = useIsMobile();
  
  const processedData = useMemo(() => {
    const grouped = data.reduce((acc, holding) => {
      const key = holding[groupBy];
      if (!acc[key]) {
        acc[key] = { name: key, value: 0 };
      }
      acc[key].value += holding['評価額(円)'];
      return acc;
    }, {});
    
    const total = Object.values(grouped).reduce((sum, item) => sum + item.value, 0);

    return Object.values(grouped)
        .map(item => ({ ...item, percentage: item.value / total }))
        .sort((a, b) => b.value - a.value);

  }, [data, groupBy]);

  const renderCustomizedLabel = useCallback(({ cx, cy, midAngle, innerRadius, outerRadius, percent, index, payload }) => {
    if (isMobile && percent < 0.04) return null;

    const RADIAN = Math.PI / 180;
    const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
    const labelRadius = outerRadius + (isMobile ? 15 : 25);
    const x = cx + labelRadius * Math.cos(-midAngle * RADIAN);
    const y = cy + labelRadius * Math.sin(-midAngle * RADIAN);
    const textAnchorX = x > cx ? x + 5 : x - 5;
    const textAnchorY = y;
    const lineStartX = cx + (outerRadius + 5) * Math.cos(-midAngle * RADIAN);
    const lineStartY = cy + (outerRadius + 5) * Math.sin(-midAngle * RADIAN);
    const lineEndX = x > cx ? textAnchorX - 5 : textAnchorX + 5;
    
    let displayName = payload.name;
    const maxNameLength = isMobile ? 6 : 10;
    if (displayName.length > maxNameLength) {
        displayName = displayName.substring(0, maxNameLength) + '...';
    }

    const formatValueCompact = (value) => {
        if (isMasked) return '***';
        if (value >= 100000000) return `${(value / 100000000).toFixed(1)}億`;
        if (value >= 10000) return `${Math.round(value / 10000)}万`;
        return Math.round(value);
    };

    return (
        <g>
            <path d={`M${lineStartX},${lineStartY} L${lineEndX},${y}`} stroke="#9ca3af" fill="none" strokeWidth={1}/>
            <text x={textAnchorX} y={textAnchorY} fill="#374151" textAnchor={x > cx ? 'start' : 'end'} dominantBaseline="central" className="text-xs sm:text-sm">
                <tspan x={textAnchorX} dy="-0.6em">{displayName}</tspan>
                <tspan x={textAnchorX} dy="1.2em" className="font-semibold">{formatValueCompact(payload.value)}</tspan>
                <tspan x={textAnchorX} dy="1.2em">({(percent * 100).toFixed(1)}%)</tspan>
            </text>
        </g>
    );
  }, [isMobile, isMasked]);

  const CustomTooltip = ({ active, payload }) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;
      return (
        <div className="bg-white/80 backdrop-blur-sm p-3 border border-gray-200 rounded-lg shadow-lg">
          <p className="font-bold text-gray-800">{data.name}</p>
          <p className="text-sm text-gray-600">
            評価額: {isMasked ? '********' : Math.round(data.value).toLocaleString()}円
          </p>
          <p className="text-sm text-gray-600">
            構成比: {(data.percentage * 100).toFixed(2)}%
          </p>
        </div>
      );
    }
    return null;
  };

  const tabs = ['資産クラス', '口座', '保有名柄'];
  
  return (
    <div className="bg-white p-4 sm:p-6 rounded-xl shadow-sm">
      <h2 className="text-xl sm:text-2xl font-bold mb-4">アセットアロケーション</h2>
      <div className="mb-4">
        <div className="inline-flex rounded-md shadow-sm bg-gray-100 p-1" role="group">
          {tabs.map(tab => (
            <button
              key={tab}
              type="button"
              onClick={() => setGroupBy(tab)}
              className={`px-3 sm:px-4 py-1.5 text-sm font-medium transition-colors rounded-md ${groupBy === tab ? 'bg-white text-blue-600 shadow' : 'text-gray-600 hover:bg-gray-200'}`}
            >
              {tab}
            </button>
          ))}
        </div>
      </div>
      <div style={{ width: '100%', height: isMobile ? 300 : 400 }}>
          <ResponsiveContainer>
              <PieChart margin={isMobile ? { top: 20, right: 60, bottom: 20, left: 60 } : { top: 20, right: 80, bottom: 20, left: 80 }}>
                  <Pie
                      data={processedData}
                      cx="50%"
                      cy="50%"
                      labelLine={false}
                      outerRadius="80%"
                      fill="#8884d8"
                      dataKey="value"
                      label={renderCustomizedLabel}
                  >
                      {processedData.map((entry, index) => (
                          <Cell key={`cell-${index}`} fill={groupBy === '資産クラス' ? getTypeColor(entry.name) : getGeneralColor(entry.name)} />
                      ))}
                  </Pie>
                  <Tooltip content={<CustomTooltip />} />
              </PieChart>
          </ResponsiveContainer>
      </div>
    </div>
  );
};

const AddAssetModal = ({ isOpen, onClose, onSave, asset }) => {
    if (!isOpen) return null;

    const [formData, setFormData] = useState({
        '資産クラス': asset ? asset['資産クラス'] : '現金',
        '口座': asset ? asset['口座'] : 'その他',
        '保有名柄': asset ? asset['保有名柄'] : '',
        '評価額(円)': asset ? asset['評価額(円)'] : '',
    });

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: name === '評価額(円)' ? (value ? parseFloat(value) : '') : value }));
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        const newAsset = {
            ...formData,
            '取得価格(円)': formData['評価額(円)'], // 取得価格と評価額を同一とする
            'id': asset ? asset.id : Date.now()
        };
        onSave(newAsset);
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={onClose}>
            <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md" onClick={e => e.stopPropagation()}>
                <h2 className="text-xl font-bold mb-4">{asset ? '資産を編集' : '資産を追加'}</h2>
                <form onSubmit={handleSubmit}>
                    <div className="space-y-4">
                        <div>
                            <label className="block text-sm font-medium text-gray-700">資産クラス</label>
                            <select name="資産クラス" value={formData['資産クラス']} onChange={handleChange} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                                {Object.keys(assetTypeOrder).sort((a, b) => assetTypeOrder[a] - assetTypeOrder[b]).map(type => (
                                    <option key={type} value={type}>{type}</option>
                                ))}
                            </select>
                        </div>
                        <div>
                            <label className="block text-sm font-medium text-gray-700">口座</label>
                            <input type="text" name="口座" value={formData['口座']} onChange={handleChange} className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                        </div>
                        <div>
                            <label className="block text-sm font-medium text-gray-700">保有名柄</label>
                            <input type="text" name="保有名柄" value={formData['保有名柄']} onChange={handleChange} required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                        </div>
                        <div>
                            <label className="block text-sm font-medium text-gray-700">評価額(円)</label>
                            <input type="number" name="評価額(円)" value={formData['評価額(円)']} onChange={handleChange} required className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" />
                        </div>
                    </div>
                    <div className="mt-6 flex justify-end space-x-3">
                        <button type="button" onClick={onClose} className="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                            キャンセル
                        </button>
                        <button type="submit" className="inline-flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                            保存
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

const HoldingsTable = ({ holdings, onUpdateHoldings, isMasked }) => {
  const [editingAsset, setEditingAsset] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [sortConfig, setSortConfig] = useState({ key: '評価額(円)', direction: 'descending' });

  const sortedHoldings = useMemo(() => {
    let sortableItems = [...holdings];
    if (sortConfig !== null) {
      sortableItems.sort((a, b) => {
        if (a[sortConfig.key] < b[sortConfig.key]) {
          return sortConfig.direction === 'ascending' ? -1 : 1;
        }
        if (a[sortConfig.key] > b[sortConfig.key]) {
          return sortConfig.direction === 'ascending' ? 1 : -1;
        }
        return 0;
      });
    }
    return sortableItems;
  }, [holdings, sortConfig]);

  const requestSort = (key) => {
    let direction = 'ascending';
    if (sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  };
  
  const handleAddClick = () => {
    setEditingAsset(null);
    setIsModalOpen(true);
  };

  const handleEditClick = (asset) => {
    setEditingAsset(asset);
    setIsModalOpen(true);
  };
  
  const handleDeleteClick = (assetId) => {
    if(window.confirm('この資産を削除してもよろしいですか？')) {
        const newHoldings = holdings.filter(h => h.id !== assetId);
        onUpdateHoldings(newHoldings);
    }
  };

  const handleSaveAsset = (asset) => {
    const existingIndex = holdings.findIndex(h => h.id === asset.id);
    let newHoldings;
    if (existingIndex > -1) {
        newHoldings = [...holdings];
        newHoldings[existingIndex] = asset;
    } else {
        newHoldings = [...holdings, asset];
    }
    onUpdateHoldings(newHoldings);
    setIsModalOpen(false);
  };

  const totals = useMemo(() => {
    const evaluation = holdings.reduce((sum, h) => sum + (h['評価額(円)'] || 0), 0);
    const acquisition = holdings.reduce((sum, h) => sum + (h['取得価格(円)'] || 0), 0);
    const gainLoss = evaluation - acquisition;
    const gainLossPercentage = acquisition === 0 ? 0 : (gainLoss / acquisition) * 100;
    return { evaluation, acquisition, gainLoss, gainLossPercentage };
  }, [holdings]);

  const headers = [
    { key: '資産クラス', label: '資産クラス' },
    { key: '口座', label: '口座' },
    { key: '保有名柄', label: '保有名柄' },
    { key: '評価額(円)', label: '評価額' },
    { key: '評価損益(円)', label: '評価損益' },
  ];

  return (
    <div className="bg-white p-4 sm:p-6 rounded-xl shadow-sm">
        <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl sm:text-2xl font-bold">保有資産一覧</h2>
            <button onClick={handleAddClick} className="flex items-center bg-blue-500 text-white px-3 py-2 rounded-md hover:bg-blue-600 text-sm font-semibold">
                <PlusIcon className="w-5 h-5 mr-1" />
                追加
            </button>
        </div>
      <div className="overflow-x-auto">
        <table className="w-full text-sm">
          <thead>
            <tr className="border-b text-left text-gray-500">
              {headers.map(({ key, label }) => (
                <th key={key} className="p-3 font-semibold cursor-pointer" onClick={() => requestSort(key)}>
                  {label}
                  {sortConfig.key === key ? (sortConfig.direction === 'ascending' ? ' ▲' : ' ▼') : ''}
                </th>
              ))}
              <th className="p-3 font-semibold text-right">操作</th>
            </tr>
          </thead>
          <tbody>
            {sortedHoldings.map((holding, index) => {
                const gainLoss = (holding['評価額(円)'] || 0) - (holding['取得価格(円)'] || 0);
                const gainLossPercentage = holding['取得価格(円)'] ? (gainLoss / holding['取得価格(円)']) * 100 : 0;
                const gainColor = gainLoss >= 0 ? 'text-red-500' : 'text-blue-500';
                return (
                    <tr key={holding.id || index} className="border-b">
                        <td className="p-3">{holding['資産クラス']}</td>
                        <td className="p-3">{holding['口座']}</td>
                        <td className="p-3 font-medium">{holding['保有名柄']}</td>
                        <td className="p-3 text-right">{isMasked ? '********' : Math.round(holding['評価額(円)']).toLocaleString()}</td>
                        <td className={`p-3 text-right whitespace-nowrap ${gainColor}`}>
                            {gainLoss >= 0 ? '+' : ''}
                            {isMasked ? '********' : Math.round(gainLoss).toLocaleString()}
                            &nbsp;({(gainLossPercentage).toFixed(2)}%)
                        </td>
                        <td className="p-3 text-right">
                           <button onClick={() => handleEditClick(holding)} className="p-1 text-gray-500 hover:text-blue-600"><PencilIcon className="w-4 h-4"/></button>
                           <button onClick={() => handleDeleteClick(holding.id)} className="p-1 text-gray-500 hover:text-red-600"><TrashIcon className="w-4 h-4"/></button>
                        </td>
                    </tr>
                )
            })}
          </tbody>
           <tfoot>
            <tr className="border-t-2 font-bold">
                <td colSpan="3" className="p-3">合計</td>
                <td className="p-3 text-right">
                    {isMasked ? '********' : Math.round(totals.evaluation).toLocaleString()}
                </td>
                <td className="p-3 text-right whitespace-nowrap">
                    <span className={totals.gainLoss >= 0 ? 'text-red-500' : 'text-blue-500'}>
                        {totals.gainLoss >= 0 ? '+' : ''}
                        {isMasked ? '********' : Math.round(totals.gainLoss).toLocaleString()}
                        &nbsp;({(totals.gainLossPercentage).toFixed(2)}%)
                    </span>
                </td>
                <td></td>
            </tr>
           </tfoot>
        </table>
      </div>
      <AddAssetModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} onSave={handleSaveAsset} asset={editingAsset}/>
    </div>
  );
};

const Dashboard = ({ portfolio, portfolios, setActivePortfolioIndex, updatePortfolio, isMasked, setIsMasked }) => {
  const dashboardRef = useRef(null);

  const summary = useMemo(() => {
    const totalValue = portfolio.holdings.reduce((sum, h) => sum + h['評価額(円)'], 0);
    const totalAcquisition = portfolio.holdings.reduce((sum, h) => sum + h['取得価格(円)'], 0);
    const totalGain = totalValue - totalAcquisition;
    const gainPercentage = totalAcquisition > 0 ? (totalGain / totalAcquisition) * 100 : 0;
    return { totalValue, totalGain, gainPercentage };
  }, [portfolio.holdings]);

  const handleDownloadImage = useCallback(() => {
    if (dashboardRef.current === null) {
      return;
    }
    htmlToImage.toPng(dashboardRef.current, { 
        quality: 0.95, 
        backgroundColor: '#f9fafb'
    })
      .then((dataUrl) => {
        const link = document.createElement('a');
        link.download = `${portfolio.name}-portfolio.png`;
        link.href = dataUrl;
        link.click();
      })
      .catch((err) => {
        console.log(err);
      });
  }, [dashboardRef, portfolio.name]);
  
  const handleUpdateHoldings = (newHoldings) => {
      updatePortfolio({ ...portfolio, holdings: newHoldings });
  };

  return (
    <div className="bg-gray-50">
        <div ref={dashboardRef}>
            <Header
                portfolioName={portfolio.name}
                portfolios={portfolios}
                setActivePortfolioIndex={setActivePortfolioIndex}
                onDownload={handleDownloadImage}
                isMasked={isMasked}
                setIsMasked={setIsMasked}
            />
            <main className="p-4 sm:p-6 space-y-4 sm:space-y-6">
                <SummaryCard summary={summary} isMasked={isMasked} />
                <PortfolioPieChart data={portfolio.holdings} isMasked={isMasked} />
                <HoldingsTable holdings={portfolio.holdings} onUpdateHoldings={handleUpdateHoldings} isMasked={isMasked} />
            </main>
        </div>
    </div>
  );
};


// --- メインアプリケーション (App.tsx) ---
function App() {
  const [portfolios, setPortfolios] = useState([]);
  const [activePortfolioIndex, setActivePortfolioIndex] = useState(null);
  const [isMasked, setIsMasked] = useState(false);

  const processCSV = (fileContent) => {
    const lines = fileContent.split(/\r\n|\n/).filter(line => line.trim() !== '');
    if (lines.length < 2) return [];

    const headers = lines[1].split(',').map(h => h.trim().replace(/"/g, ''));
    
    return lines.slice(2).map((line, idx) => {
      const values = line.split(',').map(v => v.trim().replace(/"/g, ''));
      const holding = headers.reduce((obj, header, index) => {
        const value = values[index];
        if (header.includes('(円)')) {
          obj[header] = parseFloat(value) || 0;
        } else {
          obj[header] = value;
        }
        return obj;
      }, {});
      holding.id = `${fileContent.slice(0, 10)}_${idx}`; // ファイル内容と行番号から簡易ID
      return holding;
    }).filter(h => h['保有名柄'] && h['保有名柄'] !== '---');
  };
  
  const handleFileUpload = (files) => {
    const filePromises = Array.from(files).map(file => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const holdings = processCSV(e.target.result);
            resolve({
                name: file.name.replace('.csv', ''),
                holdings: holdings,
            });
        };
        reader.onerror = reject;
        reader.readAsText(file, 'sjis');
      });
    });

    Promise.all(filePromises).then(newPortfolios => {
      const allHoldings = newPortfolios.flatMap(p => p.holdings);
      const combinedPortfolio = {
        name: 'すべての資産',
        holdings: allHoldings,
      };
      
      setPortfolios([combinedPortfolio, ...newPortfolios]);
      setActivePortfolioIndex(0);
    });
  };
  
  const updatePortfolio = (updatedPortfolio) => {
      const index = portfolios.findIndex(p => p.name === updatedPortfolio.name);
      if (index !== -1) {
          const newPortfolios = [...portfolios];
          newPortfolios[index] = updatedPortfolio;

          // 'すべての資産'も更新
          if (index !== 0) {
            const allHoldings = newPortfolios.slice(1).flatMap(p => p.holdings);
            newPortfolios[0] = { ...newPortfolios[0], holdings: allHoldings };
          }
          
          setPortfolios(newPortfolios);
      }
  };

  const activePortfolio = activePortfolioIndex !== null ? portfolios[activePortfolioIndex] : null;

  return (
    <div className="min-h-screen">
      {activePortfolio ? (
        <Dashboard
          portfolio={activePortfolio}
          portfolios={portfolios}
          setActivePortfolioIndex={setActivePortfolioIndex}
          updatePortfolio={updatePortfolio}
          isMasked={isMasked}
          setIsMasked={setIsMasked}
        />
      ) : (
        <FileUpload onFileUpload={handleFileUpload} />
      )}
    </div>
  );
}

// --- アプリケーションのレンダリング ---
const container = document.getElementById('root');
const root = ReactDOM.createRoot(container);
root.render(<App />);
    </script>
  </body>
</html>
